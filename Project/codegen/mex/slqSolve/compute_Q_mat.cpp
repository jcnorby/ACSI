/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * compute_Q_mat.cpp
 *
 * Code generation for function 'compute_Q_mat'
 *
 */

/* Include files */
#include <string.h>
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "slqSolve.h"
#include "compute_Q_mat.h"

/* Function Definitions */
void compute_Q_mat(real_T t, real_T t_wp, real_T Q[144])
{
  real_T t2;
  real_T t5[144];
  int32_T i0;

  /* COMPUTE_Q_MAT */
  /*     Q = COMPUTE_Q_MAT(T,IN2,IN3,IN4,IN5,IN6,T_WP) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.1. */
  /*     07-Nov-2018 09:38:17 */
  t2 = t - t_wp;
  t2 = muDoubleScalarExp(-(t2 * t2 * 100.0)) * 11283.79167095513;
  t5[0] = t2 + 2.0;
  memset(&t5[1], 0, 12U * sizeof(real_T));
  t5[13] = t2 + 2.0;
  memset(&t5[14], 0, 12U * sizeof(real_T));
  t5[26] = t2 + 2.0;
  memset(&t5[27], 0, 12U * sizeof(real_T));
  t5[39] = t2 + 2.0;
  memset(&t5[40], 0, 12U * sizeof(real_T));
  t5[52] = t2 + 2.0;
  memset(&t5[53], 0, 12U * sizeof(real_T));
  t5[65] = t2 + 2.0;
  memset(&t5[66], 0, 12U * sizeof(real_T));
  t5[78] = t2 + 2.0;
  memset(&t5[79], 0, 12U * sizeof(real_T));
  t5[91] = t2 + 2.0;
  memset(&t5[92], 0, 12U * sizeof(real_T));
  t5[104] = t2 + 2.0;
  memset(&t5[105], 0, 12U * sizeof(real_T));
  t5[117] = t2 + 2.0;
  memset(&t5[118], 0, 12U * sizeof(real_T));
  t5[130] = t2 + 2.0;
  memset(&t5[131], 0, 12U * sizeof(real_T));
  t5[143] = t2;
  for (i0 = 0; i0 < 12; i0++) {
    memcpy(&Q[i0 * 12], &t5[i0 * 12], 12U * sizeof(real_T));
  }
}

/* End of code generation (compute_Q_mat.cpp) */
